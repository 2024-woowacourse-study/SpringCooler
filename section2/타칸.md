# 프로젝트 요구사항

- 비즈니스 요구사항이 미정이여도 역할과 구현을 나누어서 구현체는 언제든지 갈아끼울 수 있도록 해준다.
- 설계 과정
1. 도메인 협력 관계 설계
2. 1번 이후 개발자는 구체화 하여 클래스 다이어그램을 설계
3. 실제 프로그램이 돌아갔을 때 어떤 구현체가 들어갔을 떄 사용되는 구체 다이어그램을 설계

## 실제 어플리케이션 구현
- 설계 과정에 따라 역할과 구현을 분리해주기 위해 인터페이스와 구현체를 활용
- 인터페이스에 역할을 정의하고 구현체에서 실제 동작을 정의해주어서 확장 가능한 설계를 구현

## 요구사항이 변경 - 새로운 할인 정책 확장
- 역할과 구현을 분리하기 위해 다형성을 활용했다.
- But, 할인 정책 변경시 OCP 를 지킬 수 없다.

```java
public class OrderServiceImpl implements OrderService{

    private DiscountPolicy discountPolicy = new FixDiscountPolicy();
    ...
```
에서

```java
public class OrderServiceImpl implements OrderService{

    // private DiscountPolicy discountPolicy = new FixDiscountPolicy();
    private DiscountPolicy discountPolicy = new RateDiscountPolicy();
    ...
```
와 같이 변경

- 우리는 지금까지 인터페이스에만 의존하고 있다고 생각했지만 구체화에도 의존하고 있다.
<img width="1040" alt="image" src="https://github.com/2024-woowacourse-study/spring-basic/assets/78288539/69355f64-aa47-4644-8e05-ee0ae4061d9d">
- 할인 정책을 `FixDiscountPolicy` 에서 `RateDiscountPolicy` 로 변경 시 `OrderServiceImpl` 의 코드도 변경되어야 한다.
  - 즉 의존관계가 있다.
  - 변경이 작지만 그래도 **OCP 위반**이다.
  - 또한 구현체를 의존하고 있기 때문에 **DIP 위반**이다.

## 어떻게 해결할 수 있을까??
<img width="1033" alt="image" src="https://github.com/2024-woowacourse-study/spring-basic/assets/78288539/585018d8-04f5-4576-8553-422cdeb07f97">
- 추상에만 의존하도록 변경하면 된다.

```java
public class OrderServiceImpl implements OrderService{

    private DiscountPolicy discountPolicy;
    ...
```
위와 같이 변경하면 된다.
- 구현체를 모르기 때문에 의존성이 없다.
- 대신 누군가 외부에서 구현체를 넣어주면 된다.

## 관심사의 분리
- 애플리케이션을 하나의 공연이라고 가정하자. 역할은 배역이고 구현체는 배우이다.
- 공연에서 역할을 누가할지 정하는 책임은 누구한테 있을까?? 배우의 역할이 아니다. 공연 기획자의 역할이다.
  - 배우가 섭외 책임까지 있으면 섭외 + 연기 등 너무 많은 책임을 가지게 있게 된다.
  - 관심사의 분리가 필요하다.
- 따라서 배우는 연기에만 집중하도록하고, 섭외의 책임만을 가지는 **공연 기획자**의 필요성이 느껴진다.
- 공연 기획자를 만들어서 배우와 책임을 명확히 분리하자.

## AppConfig 의 등장
```java
public class AppConfig {

    MemberService memberService() {
        return new MemberServiceImpl(new MemoryMemberRepository());
    }

    OrderService orderService() {
        return new OrderServiceImpl(new MemoryMemberRepository(), new FixDiscountPolicy());
    }
}
```
- `AppConfig` 가 `MemberService` 의 구현체를 리턴해준다.

```java
public class MemberServiceImpl implements MemberService{

    private final MemberRepository memberRepository;

    public MemberServiceImpl(MemberRepository memberRepository) {
        this.memberRepository = memberRepository;
    }
    ...
```
- `MemberServiceImpl` 는 이제 `MemberRepository` 에 누가 들어올지 몰라도 된다.
  - 줄리엣 배우로 누가 올 지 몰라도 된다.
  - 즉 역할에만 집중하면 된다. **실행에만 집중**하면 된다.
  - 어떤 배우가 들어올지는 `AppConfig`(공연기획자) 가 정해줄 것이다.
<img width="908" alt="image" src="https://github.com/2024-woowacourse-study/spring-basic/assets/78288539/230f3607-2612-4a17-995a-2ea2a47b1dd0">
- DIP 완성
  - `MemberServiceImpl` 는 이제 `MemberRepository` 인 추상에만 의존하면 된다.
  - 이제 구체화에 의존하지 않고, 추상에만 의존하면 된다.
  - `MemberServiceImpl` 는 이제 `MemberRepository` 인 추상에만 의존하면 된다.
  - 클라이언트인 `MemberServiceImpl` 입장에서는 마치 외부에서 주입해주는 것 같다.
  - DI(Dependency Injection) 우리 말로 **의존관계 주입**이라고 한다.
 
- 이제부터 각 배우들은 담당 기능 실행에만 고민하면 된다. 연기에만 고민하면 된다.
- 어떤 배우가 올지는 공연 기획자 (AppConfig)에게 맡기면 된다.
