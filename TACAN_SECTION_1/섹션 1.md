# 옛날 옛적 자바는..

EJB 라는 자바진영 표준 기술이 있었음 → 고급 기술을 편리하게 지원했음, ORM 이 있었음

But, 비쌌음

진짜 복잡하고 어렵고 지저분했음 → POJO (옛날 순수 자바로 돌아가자) 라는 말이 나올정도였음

그래서 2명의 개발자가 오픈소스를 만들었음,

# JPA가 등장하게 된 배경

그 중 한명의 개발자가 하이버네이트를 만들었음

EJB 보다 사람들이 하이버네이트를 사용하니까 하이버네이트를 만든 개발자를 데려와서 거의 복사 붙여넣기 해서 자바 표준을 만들었는데 그것이 바로 JPA.

JPA 는 인터페이스이고 JPA 의 구현체로는 여러가지가 있는데 그 중에서 하이버네이트를 거의 대부분 사용함

# 스프링이 등장하게 된 배경

다른 한명(로드 존슨)은 책을 출간했는데 이것이 전설의 시초.

로드 존슨은 EJB의 문제점을 지적하면서 EJB를 사용하지 않고 고품질로 확장 가능한 애플리케이션을 만들 수 있는 것을 보여주었음. 여기에 사용한 예제들에 스프링의 핵심 개념과 기반 코드가 들어있음

책 출간 이후 유겐 휠러, 얀 카로프 두 명의 개발자가 로드 존슨에게 오픈소스 프로젝트를 제안했고 그래서 등장한 것이 스프링이다. 스프링은 겨울(EJB)를 넘어 새로운 시작이라는 뜻

# 왜 배경을 설명한 것인가?

우리는 강의동안 저 당시로 돌아갈 것이다. 어떤 예제 코드였길래 유겐 휠러, 얀 카로프 두 명의 개발자가 회사를 그만두고 오픈소스를 제안했을까? 분명히 이유가 있을 것이다. 왜 사람들이 그렇게 열광을 했고 왜 스프링이 유명해졌는지 당시로 돌아가서 예제를 만들어보면서 느껴볼 것이다.

# 스프링이란??

![[Pasted image 20240312195804.png]]
스프링 관련 기술은 여러가지가 있다.

그 중에서 가장 중요한 것은 **스프링 프레임워크**와 스프링을 편리하게 사용할 수 있게 도와주는 **스프링 부트**가 있다.

### 스프링 프레임워크
가장 중요한 것은 스프링 프레임워크이다. 이 안에는 여러 기술이 있다.
![[Pasted image 20240312200000.png]]
기술들을 통합해서 스프링 프레임워크라고 한다.
이 강의에서는 핵심 기술에 대해서 다룰 것이다.

### 스프링 부트
![[Pasted image 20240312200124.png]]
스프링 부트는 스프링을 편리하게 사용할 수 있도록 지원한다.
여러가지가 있는데 웹 서버를 별도로 설치하지 않아도 된다. 그리고 라이브러리를 설치할 때 여러개 묶어서 땡겨야하는데 이것을 자동으로 해준다. 서드파티 버전 관리 및 잘 맞는지 우리가 상관 안해도 된다. 스프링 부트에서 다해준다. 모니터링 기능. 웬만한 관례 설정을 자동으로 해줌.

## 스프링 단어??
스프링 단어는 어떤걸 의미할까?? 조금 애매하다. 문맥에 따라 다른 의미를 가진다.

1. 스프링 DI 컨테이너 기술
2. 스프링 프레임워크
3. 스프링 부트, 스프링 프레임워크 등을 모두 포함한 스프링 생태계


## 스프링을 왜 만들었을까??

핵심 개념. 기술 컨셉은 항상 단순하다. 
이 단순한 핵심 컨셉이 너무 좋다. 
그래서 스프링이 이렇게 커졌다.

왜?? 도대체 왜 그렇게 다들 스프링에 열광할까??
핵심 컨셉을 제대로 이해하고 사용해야 스프링을 자연스럽게 이해할 수 있다.
단순히 기술만 안다고 스프링을 아는 것이 아니다. 핵심 컨셉을 이해하자.

## 스프링 진짜 핵심

스프링은 자바 언어 기반 프레임 워크다.
자바는 객체지향 언어이다. ==스프링은 **좋은 객체 지향** 어플리캐이션을 개발할 수 있도록 도와주는 프레임워크이다.==

예전에 EJB 를 사용하면서 EJB에 의존적으로 개발하게 되어 객체 지향이 가진 좋은 장점을 다 잃어버렸다. 그래서 순수 자바로 돌아가자는 말도 등장한 것이다.

스프링은 자바가 가진 좋은 객체 지향을 잘 활용할 수 있게 도와준 도구였다.
그러면 좋은 객체 지향이 뭘까??


## 객체 지향 프로그래밍
좋은 객체 지향에 대해 이해하기 전에 우선 객체 지향 프로그래밍이 뭘까??
객체 지향 프로그래밍은 긴 사전적 의미가 있지만 핵심은 이것이다.
1. 객체들의 모임이다.
2. 객체들이 메시지를 통해 서로 협력한다.
3. 유연하고 변경 용이하다.

### 유연하고 변경 용이??
레고를 갈아 끼듯이, 부품을 갈아 끼우듯이, 컴포넌트를 쉽고 유연하게 변경하면서 개발할 수 있는 방법
바로 **다형성**이다.

## 다형성

### 다형성을 실세계에 비유

다형성을 실세계에 비유하면 1:1 로 정확히 매칭되지 않는다.
그래도 실세계에 비유하면 이해하기 편함
그래서 이렇게 비유할 것이다. 세상을 **역할**과 **구현**으로 구분하자.

### 운전자 - 자동차
운전자라는 역할이 있고, 자동차라는 역할이 있다.
![[Pasted image 20240312201937.png]]
운전자는 자동차가 바뀌어도 운전을 할 수 있을까?? 당연하다.
자동차가 K3 에서 아반떼로 바뀐다고 하여도 운전자한테는 영향을 끼치지 않는다.

유연하고 변경 용이하다. -> 자동차가 바뀌어도 다른 운전 면허를 따야하지 않는다. 그냥 운전할 수 있다.
자동차의 역할 인터페이스에 따라서 자동차를 만들었기 떄문이다.

운전자는 자동차 인터페이스에만 의존한다.
운전자는 자동차 내부 구조가 바뀌어도 자동차 역할만 그대로 하고 있다면 아무 상관없다.

즉, 아무리 새롭게 자동차가 나와도 기존의 자동차 역할만 그대로 따라갈 수 있으면 자동차 세상을 무한히 확장 가능하다. 다시 말해서 클라이언트에게 영향을 끼치지 않고 새로운 기능을 제공할 수 있다.

### 공연과 기획
![[Pasted image 20240312202354.png]]
또 다른 비유로 로미오와 줄리엣 공연을 들 수 있다.
로미오와 줄리엣 공연을 할 때는, 배우는 대체가 가능하다.
역할과 구현을 나누면 변경 가능한 대체 가능성이 생긴다.
이것이 바로 유연하고 변경에 용이하다는 뜻이다.

내부 구조를 몰라도 된다. 로미오 역할을 하는 사람은 줄리엣이 누가 와든 상관없다. 어떤 사람이 와도 줄리엣 역할만 하먄 된다. 즉, 다른 대상으로 대체 가능하다.

## 역할과 구현으로 분리

역할과 구현을 분리하면 세상이 단순해지고, 유연해지고, 변경도 편해진다.
- 클라이언트는 대상의 역할(인터페이스)만 알면 된다.
- 클라이언트는 구현 대상의 내부 구조가 변해도 영향을 받지 않는다.
- 클라이언트는 구현 대상의 내부 구조를 몰라도 된다.
- 구현 대상 자체가 바뀌어도 클라이언트는 영향을 받지 않는다.

이것이 역할과 구현을 분리하는 것의 장점이다.
자바 언어에서는 다형성을 차용해서 이를 적용한다.
- 역할 : 인터페이스
- 구현 : 인터페이스를 구현한 객체


## 객체의 협력이라는 관계

혼자 있는 객체는 없다.
클라이언트 : 요청, 서버 : 응답
수많은 객체가 서로 요청하고 응답하면서 협력 관계를 가진다.


## 자바 언어의 다형성
![[Pasted image 20240312204155.png]]
자바의 다형성으로 인터페이스를 구현한 객체를 실행 시점에 유연하게 변경할 수 있는 Java 언어가 가진 장점이다. 이를 활용해서 인터페이스를 구현한 객체의 인스턴스를 실행 시점에 유연하게 변경할 수 있다.

클라이언트를 변경하지 않고, 서버의 구현 기능을 유연하게 변경 가능할 수 있는 것이 다형성의 본질이다.


## 역할과 구현으로 분리의 한계
그런데 문제는 역할이 바뀌게 되면 클라이언트, 서버 모두 큰 변화가 발생한다.
자동차가 이륙을 해야한다면?? 대본 자체가 변경된다면?? 어떨까??
따라서 인터페이스(역할)을 안정적으로 잘 설계하는 것이 매우 중요하다.

## 스프링과 객체 지향
객체지향의 꽃은 다형성이다. 스프링은 이러한 다형성을 극대화 해서 활용할 수 있게 도와준다.
스프링을 활용하면 자동차 구현체가 바뀌듯이, 공연의 배우가 바뀌듯이 구현을 편리하게 변경 가능하다.


# SOLID
좋은 객체 지향을 하기 위해 지켜야하는 5가지 원칙

### SRP (단일 책임 원칙)
하나의 책임이라는 말이 사실 모호하다.
중요한 판단 기준은 **변경**이다. 변경시 파격이 적으면 SRP 를 잘 따른 것이다.

책임의 범위를 적절하게 잘 정하는 것이 객체지향 설계의 묘미이다.

### OCP (개방 폐쇄 법칙)
확장에는 열려있으나 변경에는 닫혀있어야 한다는 원칙이다.
어떻게 변경에 닫히면서 확장할 수 있을까?? 다형성을 활용해보자.
역할과 구현을 분리하면 OCP 를 지킬 수 있다.

역할에 의존하면 기존 코드 없이(변경 없이) 확장할 수 있다.
![[Pasted image 20240312205554.png]]
그런데 구현 객체를 변경하려면 클라이언트 코드를 변경해야한다.
아무리 인터페이스만 의존한다고 하더라고 구현체를 주입해주는 코드는 변경해줘야한다.
분명 다형성을 활용했지만 OCP를 지킬 수 없다.

어떻게 해결할 수 있을까?? 관계를 설정해주는 별도의 무언가가 있어야한다. 이걸 스프링 컨테이너가 해준다.
이후 뒤에서 실제로 살펴보자.

### LSP (리스코츠 치환 원칙)
인터페이스가 있고 구현체가 있을 때. 인터페이스를 구현한 구현체는 인터페이스 규약을 지켜야한다.
자동차 인터페이스의 액셀은 앞으로 가야한다.
그런데 엑셀을 눌렀을 때 뒤로가면 안되는 것이다. 
느리더라도 앞으로 가야한다.

따라서 인터페이스를 구현한 구현체는 해당 인터페이스의 규약을 지켜야한다. 이것이  리스코츠 치환 원칙이다.

### ISP (인터페이스 분리 원칙)
특정 클라이언트의 범용 인터페이스 하나보단 여러개 인터페이스가 낫다.

자동차 인터페이스를 운전 인터페이스와 정비 인터페이스로 분리하게 된다면 사용자 클라이언트도 운전 클라이언트와 정비 클라이언트로 분리할 수 있다.

이렇게 분리되면 정비 인터페이스 자체가 변해도 운전자 클라이언트에는 영향을 끼치지 않는다.
즉, 변경에 의한 파급효과가 작아진다. 이는 인터페이스를 더 명확하게 하고 대체 가능성을 높인다.

### DIP (의존관계 분리 원칙)
프로그래머는 추상화에 의존해야지 구체화에 의존하면 안된다.

클라이언트 코드가 인터페이스만 바라보고 구현 클래스를 지켜보면 안된다.

계속 해왔던 말과 동일하다. 역할에 의존해야지 구현에 의존하지 말하는 뜻이다.

![[Pasted image 20240312205554.png]]
아까 OCP에서 봤던 코드를 다시 살펴보자. 
`MemberService`(클라이언트)는 분명히 인터페이스에 의존한다. 그러나 구현체도 같이 의존하고 있다.
(의존한다는 말은 알고 있다는 것과 일맥상통하다)

위 코드를 살펴보면 `MemberReposiotry` 라는 인터페이스에 의존하고 있다. 그러나 `new MemoryMemberRepository` 나 `new JdbcMemberRepository` 같이 구현체도 동시의 의존한다는 것을 볼 수 있다.  즉 DIP 를 위반한다.

그래서 코드를 변경해야되는 문제가 발생한다.
그럼 어떻게 해결할 수 있을까?? 그 방법을 뒤에서 알아볼 것이다.


# 다시 스프링으로

사실 스프링은 다음에 설명할 기술들로 다형성 + DIP, OCP를 가능하게 지원해준다.
- DI(Dependency Injection) : 의존관계, 의존성 주입
- DI 컨테이너 : 자바 객체들을 컨테이너 안에 넣고 서로의 의존관계를 연결하고 주입해준다.

스프링이 없던 시절에 순수 자바로 OCP, DIP 원칙을 지키면서 개발을 하려고 해봤는데 너무 할 일이 많아졌다. 배보다 배꼽이 커져버린 것이다. 그래서 프레임워크로 만들어버렸다. 





